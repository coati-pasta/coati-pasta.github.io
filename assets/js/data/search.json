[ { "title": "Ubiquiti Unifi G4 doorbell custom ring sound", "url": "/posts/doorbell/", "categories": "Home projects, Smart home", "tags": "ubiquiti, unifi, G4, doorbell", "date": "2021-12-14 17:45:00 +0100", "snippet": "Here’s how to customize the rings sound played on your Ubiquiti Unfi Doorbell G4. At the time of writing ubiquiti does not offer any option to customize the sound played on the doorbell when it’s pressed (not the chime, the noise the camera doorbell makes itself). So here it goes.PrerequisiteYou are going to have to enable ssh access to your ubquiti camera’s on your instance of unifi protect (udm, udmpro, cloudkey). This is done by connecting through ssh to your instance runnning unifi protect. And creating/editing the config file to allow this, see ubiquiti website.Getting the correct sound fileThe sound files played on the doorbell have some specific properties that need to be taken in to account. We can’t just slap any audiofile on there and expect it to play. The following is what I did: If not the case: install audacity (audio editing software, free &amp;amp; open source). Find a suitable audio piece. Probably not too crazy long, can be shortened in audacity. Adapt the gain levels to make sure it’s not too quiet. Convert the track to mono Export to .wav in 16kbps Beam the sound file to the doorbellCopy it using scp to the doorbell, note that the destionation file is custom.wav for ease of use later:scp insert_your_song.wav ubnt@doorbell_ip:/var/etc/sounds/custom.wav Edit configuration filesUnder /var/etc/persistent there are some config files we need to play with:vi /var/etc/persistent/ubnt_sounds_leds.confPress i for edit, edit the “Chime.wav” to “../../../../var/etc/persistent/custom.wav” then press ESC and then :x to save. Hit enter.cat /var/etc/persistent/ubnt_sounds_leds.confVerify that the output looks like thisNow all that’s left to do is to get the ubnt_sounds_leds daemon to restart so: Search for the PID of the ubnt_sounds_leds:ps Execute the command to kill that daemon:kill -TERM __your-PID__ And that is it, go ring the doorbell to verify. Do note that this will all reset if the doorbell camera loses power and restarts. Have not found a way to make it permanent just yet." }, { "title": "Windows PSSession MOTD", "url": "/posts/windows_motd/", "categories": "Windows, Server administration", "tags": "pinned, windows, winrm, pssession, pssessionconfiguration, motd, banner", "date": "2021-12-13 10:30:00 +0100", "snippet": "Setting up a completely new windows environment comes with some one time configurations. One of those is legal notice texts and banners. Aside from the usual legalnotice text registry key, which only sets a legal message for Remote Desktop Connections. There is also a way to configure MOTD banners when connecting over Winrm to a windows host in powershell (Enter-PSSession).Here’s an example of what it might look like:Set upTo have a nice banner as shown in the screenshot above. We need the following: Environment variables, useful info to show upon startup Ensure the presence of the banner startup script Set the remote session configurationFor the sake of being generic let’s say we decide on a motd_path filepath, which can be interpreted as: ‘C:\\whereveryouwant\\motd&#39;. In the environment for which I configured this we are using Puppet as a configuration manager. But I suppose this could be translated to any other configuration manager. 1. Environment variablesAside from a nice logo that is shown, we would like to see some useful information concerning the machine you are connecting to. This could be the machine name, ip address, current disk space used, full FQDN, status of certain services. The needs may differ here, change at will.In my case I use a configuration manager to ensure the presence of a PowerShell Datafile (.psd1) in the motd_path, parsed with some environment variables. Using the .psd1 format allows us to import the file in PowerShell as nice hashtable. Since I’m using puppet at this time, I am putting this file as a ruby template in a module (applied on the machine). Which will parse the variables in between the ‘&amp;lt;%= %&amp;gt;’ with machine variables and facts. The psd1 file looks something like:@{ someInfo1 = &#39;&amp;lt;%= @someInfo1 %&amp;gt;&#39;; someInfo2 = &#39;&amp;lt;%= @someInfo2 %&amp;gt;&#39;; someInfo3 = &#39;&amp;lt;%= @someInfo3 %&amp;gt;&#39;; someInfo4 = &#39;&amp;lt;%= @someInfo4 %&amp;gt;&#39;; someInfo5 = &#39;&amp;lt;%= @someInfo5 %&amp;gt;&#39;; Datacenter = &#39;&amp;lt;%= @env_dc %&amp;gt;&#39;; someInfo6 = &#39;&amp;lt;%= @someInfo6 %&amp;gt;&#39;; &#39;AD Domain&#39; = &#39;&amp;lt;%= @ad_domain %&amp;gt;&#39;; Domain = &#39;&amp;lt;%= @domain %&amp;gt;&#39;; OS = &#39;&amp;lt;%= @windows_product_name %&amp;gt;&#39;; Hostname = &#39;&amp;lt;%= @hostname %&amp;gt;&#39;; &#39;Server Type&#39; = &#39;&amp;lt;%= @operatingsystemtype %&amp;gt;&#39;; someInfo9 = &#39;&amp;lt;%= @environment %&amp;gt;&#39;;}The .psd1 will be imported in to a variable used throughout the nexts script to put the info in the right place. I can imagine that this can be reworked to contain perhaps performance metrics or anything really. 2. StartupscsriptNow for the second file we need to have in the motd_path. This is the actual script that will run at startup to display the banner. A couple of things to note: Save the file as UTF8 With BOM. If this is not done, the characters for the borders will be all messed up because of incompatible file encoding. When importing the psd1 file, I’m again parsing a Ruby variable in puppet to ensure to have the correct path. This could be replaced with some declaration on where the script is located (something like “$ScriptPath = Split-Path $MyInvocation.MyCommand.Path”) In the beginning of the script (the switch statement) I’m deciding whether or not to show the logo because of screen size constraints. I thought it’d be nice to have scaling responsive message. And if the console size is ridiculously small, i’m resorting to a simple echo of the legalnotice text. ## ATTENTION :: This file needs to be saved with encoding UTF8 With BOM !!! otherwise special characters will not be loaded properly## Dependency :: In the specified MOTD Path there needs to be a MOTDVars.psd1 file which contains a hashtable of environment variables!#region setVariables# Assign static variables based on banner sizeswitch ($Host.UI.RawUI.WindowSize.Width) { {$_ -ge 97}{ $drawBox = $true $windowsLogo = $true $top_banner = @&quot; ╭──────────────────────────╮ ╒═══════════════════════════════╡ ⚠ Warning ⚠ ╞═══════════════════════════════╕ │ ╰──────────────────────────╯ │ │ │ │ Access is restricted to authorised users ONLY. │ │ All connections and transactions are monitored. │ │ By continuing past this point, you consent to this monitoring. │ │ │&quot;@ $div = @&quot; ├──────────────────────────────────────────────────────────────────────────────────────────┤&quot;@ $spacer = &#39; │ &#39; $width = $div.length $foot = &#39; └&#39; + &#39;─&#39; * ($width - 6) + &#39;┘&#39; $limit = 34 } {$_ -ge 54 -AND $_ -lt 97} { $drawBox = $true $top_banner = @&quot; ╭──────────────────────────────╮ ╒═══════╡ ⚠ Warning ⚠ ╞═══════╕ │ ╰──────────────────────────────╯ │ │ │ │ Access is restricted to authorised │ │ users ONLY. All transactions and │ │ connections are monitored. │ │ By continuing past this point, you │ │ consent to this monitoring. │ │ │&quot;@ $div = @&quot; ├──────────────────────────────────────────────┤&quot;@ $width = $div.length $spacer = &#39; │ &#39; $foot = &#39; └&#39; + &#39;─&#39; * ($width - 6) + &#39;┘&#39; $limit = 29 } {$_ -lt 54} { Write-Host &quot;!! Warning !!&quot; Write-Host &quot;Access is restricted to authorised users ONLY. All connections and transactions are monitored. By continuing past this point, you consent to this monitoring.&quot; } }#import device info ## Import MOTDVars.psD1 $import = Import-PowerShellDataFile &#39;&amp;lt;%= @motd_path %&amp;gt;\\motdVars.psd1&#39;; $motdVars = @{}; $import.Keys | % { if ($import.$_.length -gt $limit ) { $motdVars += @{ $_ = &#39;error::var_too_long&#39; } }else { $motdVars += @{ $_ = $import.$_ } } } $Date = Get-Date $env_color = switch ($motdVars.someInfo9) { &#39;dev&#39; { &quot;DarkGreen&quot; } &#39;staging&#39; { &quot;DarkBlue&quot; } &#39;production&#39; { &quot;Red&quot; } Default { &quot;Yellow&quot; } } $body = @{ 1 = @{ WindowsLogo = @{ 1 = @{ &quot; &quot; = &#39;Black&#39; }; 2 = @{ &quot; &quot; = &#39;Black&#39;; }; } ; Info = @{ &#39;&#39; = &#39;Yellow&#39; ; } ; }; 2 = @{ WindowsLogo = @{ 1 = @{ &quot; ,.=:^!^!t3Z3z.,&quot; = &#39;Red&#39; } ; 2 = @{ &quot; &quot; = &#39;Blue&#39;; }; } ; Info = @{ $Date = $env_color; } ; }; 3 = @{ WindowsLogo = @{ 1 = @{ &quot; :tt:::tt333EE3 &quot; = &#39;Red&#39; } ; 2 = @{ &quot; &quot; = &#39;Black&#39;; }; } ; Info = @{ &#39;&#39; = &#39;Black&#39; ; } ; }; 4 = @{ WindowsLogo = @{ 1 = @{ &quot; Et:::ztt33EEE &quot; = &#39;Red&#39; } ; 2 = @{ &quot; @Ee., .., &quot; = &#39;Green&#39;; }; } ; Info = @{ &#39;Hostname&#39; = &#39;Yellow&#39; ; } ; }; 5 = @{ WindowsLogo = @{ 1 = @{ &quot; ;tt:::tt333EE7&quot; = &#39;Red&#39; } ; 2 = @{ &quot; ;EEEEEEttttt33# &quot; = &#39;Green&#39;; }; } ; Info = @{ &#39;OS&#39; = &#39;Yellow&#39; ; } ; }; 6 = @{ WindowsLogo = @{ 1 = @{ &quot; :Et:::zt333EEQ.&quot; = &#39;Red&#39; } ; 2 = @{ &quot; SEEEEEttttt33QL &quot; = &#39;Green&#39;; }; } ; Info = @{ &#39;Server Type&#39;= &#39;Yellow&#39; ; } ; }; 7 = @{ WindowsLogo = @{ 1 = @{ &quot; it::::tt333EEF&quot; = &#39;Red&#39; } ; 2 = @{ &quot; @EEEEEEttttt33F &quot; = &#39;Green&#39;; }; } ; Info = @{ &#39;&#39; = &#39;Black&#39; ; } ; }; 8 = @{ WindowsLogo = @{ 1 = @{ &quot; ;3=*^``````&#39;*4EEV&quot; = &#39;Red&#39; } ; 2 = @{ &quot; :EEEEEEttttt33@. &quot; = &#39;Green&#39;; }; } ; Info = @{ &#39;someInfo1&#39; = &#39;Yellow&#39; ; } ; }; 9 = @{ WindowsLogo = @{ 1 = @{ &quot; ,.=::::it=., &quot; = &#39;Cyan&#39; } ; 2 = @{ &quot;``&quot; = &#39;Red&#39;; }; 3 = @{&quot; @EEEEEEtttz33QF &quot; = &#39;Green&#39;; }; } ; Info = @{ &#39;someInfo2&#39; = &#39;Yellow&#39; ; } ; }; 10 = @{ WindowsLogo = @{ 1 = @{ &quot; ;::::::::zt33) &quot; = &#39;Cyan&#39; } ; 2 = @{ &quot; &#39;4EEEtttji3P* &quot; = &#39;Green&#39;; }; } ; Info = @{ &#39;someInfo3&#39; = &#39;Yellow&#39; ; } ; }; 11 = @{ WindowsLogo = @{ 1 = @{ &quot; :t::::::::tt33.&quot; = &#39;Cyan&#39; } ; 2 = @{ &quot;:Z3z.. &quot; = &#39;Yellow&#39;; &quot; ````&quot; = &#39;Green&#39; }; 3 = @{&quot; ,..g. &quot; = &#39;Yellow&#39;; }; } ; Info = @{ &#39;someInfo4&#39; = &#39;Yellow&#39; ; } ; }; 12 = @{ WindowsLogo = @{ 1 = @{ &quot; i::::::::zt33F&quot; = &#39;Cyan&#39; } ; 2 = @{ &quot; AEEEtttt::::ztF &quot; = &#39;Yellow&#39;; }; } ; Info = @{ &#39;&#39; = &#39;Black&#39; ; } ; }; 13 = @{ WindowsLogo = @{ 1 = @{ &quot; ;:::::::::t33V&quot; = &#39;Cyan&#39; } ; 2 = @{ &quot; ;EEEttttt::::t3 &quot; = &#39;Yellow&#39;; }; } ; Info = @{ &#39;someInfo5&#39; = &#39;Yellow&#39; ; } ; }; 14 = @{ WindowsLogo = @{ 1 = @{ &quot; E::::::::zt33L&quot; = &#39;Cyan&#39; } ; 2 = @{ &quot; @EEEtttt::::z3F &quot; = &#39;Yellow&#39;; }; } ; Info = @{ &#39;Datacenter&#39; = &#39;Yellow&#39; ; } ; }; 15 = @{ WindowsLogo = @{ 1 = @{ &quot; {3=*^``````&#39;*4E3)&quot; = &#39;Cyan&#39; } ; 2 = @{ &quot; ;EEEtttt:::::tZ`` &quot; = &#39;Yellow&#39;; }; } ; Info = @{ &#39;someInfo6&#39; = &#39;Yellow&#39; ; } ; }; 16 = @{ WindowsLogo = @{ 1 = @{ &quot; ``&quot; = &#39;Cyan&#39; } ; 2 = @{ &quot; :EEEEtttt::::z7 &quot; = &#39;Yellow&#39;; }; } ; Info = @{ &#39;AD Domain&#39; = &#39;Yellow&#39; ; } ; }; 17 = @{ WindowsLogo = @{ 1 = @{ &quot; &#39;VEzjt:;;z&amp;gt;*`` &quot; = &#39;Yellow&#39;; }; } ; Info = @{ &#39;someInfo9&#39; = &#39;Yellow&#39; ; } ; }; 18 = @{ WindowsLogo = @{ 1 = @{ &quot; ```` &quot; = &#39;Yellow&#39;; }; } ; Info = @{ &#39;&#39; = &#39;Black&#39; ; } ; }; }#endregion setvariables# Write Actual Bannerif($drawBox){ write-host $top_banner -ForegroundColor $env_color write-host $div -ForegroundColor $env_color ## write body for ($i = 1; $i -le $body.Count; $i++) { $lineLength = 0 Write-Host $spacer -NoNewline -ForegroundColor $env_color if($windowsLogo){ for ($x = 1; $x -le $body.$i.WindowsLogo.Keys.Count; $x++) { $body.$i.WindowsLogo.$x.Keys | % { Write-host $_ -NoNewline -ForegroundColor $body.$i.WindowsLogo.$x.$_ $lineLength += $_.length } } } $body.$i.Info.Keys | % { $info_key = &quot;$($_)$(if($motdVars.$_){&#39;: &#39;})&quot; $info_var = &quot;$($motdVars.$_)&quot; Write-host $info_key -NoNewline -ForegroundColor $body.$i.Info.$_ Write-host $info_var -NoNewline -ForegroundColor Gray $lineLength += ($info_key.length + $info_var.length) } Write-Host &quot;$(&#39; &#39;*($width - $spacer.length - $lineLength -1) + &#39;│&#39;)&quot; -ForegroundColor $env_color } Write-Host (&quot;$foot&quot;) -ForegroundColor $env_color}Note: I have to disclaim that I found the windows logo on GitHub, credit where credit is due. I decided to rewrite it abit to have the logo in a hashtable together with the session info. And to build the banner with the nested loops. My thought was that it’s shorter, nicer and more readable. However using nested loops like that my come with some performance impact. Maybe it’s a bit harder on the cpu when the script runs. I found when testing that it was not that bad of a delay compared to using the millions of write-host statements. Depends on the case and what you prefer. 3. Set-PSSessionConfigurationNow that we have all the necessary files in place, we need to configure the machine to run the motd.ps1 script on startup of a Remote Session. We need to point the PSSessionConfiguration for the microsoft.powershell profile to the startupscript, or create a new profile. Again depends on the use case.#decide if config needs to be setif((Get-PSSessionConfiguration | where name -like &#39;microsoft.powershell&#39;).startupscript -eq &#39;$($motd_path)\\\\motd.ps1&#39;){ # Set the config Set-PSSessionConfiguration -Name &#39;microsoft.powershell&#39; -startupscript &#39;${motd_path}\\\\motd.ps1&#39; -NoServiceRestart}else{ exit 0}I prefer to put the NoServiceRestart when setting the configuration because when testing in my environment I found that setting the startupscript in this case did not require the pssesion (winrm) service to restart. Warning: if you do not specify the argument NoServiceRestart, the winrm service will restart and all current remote session will be disconnected…Once all this is configured, once you do an Enter-PSSession to a machine this is configured on. You should see a nice banner.Sources Special credit goes to the github user joeyaiello, whose project inspired me, specifically for the windows logo. Microsoft Doc: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/set-pssessionconfiguration?view=powershell-7.2 " }, { "title": "Welcome", "url": "/posts/welcome/", "categories": "General", "tags": "hello_world", "date": "2021-11-24 17:45:00 +0100", "snippet": "IntroOn this blog I would like to share projects I’m doing at home or professionally. This will go from server administration, system engineering, automation (which I’m doing in my current role) to some home networking projects. Playing around with some open source projects like pihole, installing some network camera’s, video doorbel, etc." } ]
